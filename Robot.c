#pragma config(Sensor, S1,     sensorL,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     sensorF,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     sensorR,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sensorD,        sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          motorL,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          motorR,        tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// writeDebugStream() is printf()
// 1 to turn left, 2 to turn right, 3 to go straight, 456 are saved for circular path
int arr[3] = {1, 2, 3};

void moveForward();
void aturnLeft();
void aturnRight();

task main(){
	int index;
	int length = sizeof(arr) / 2; //divide by 2 for int, divide by 20 for string
	for(index = 0; index < length - 1; index++){
		int a = arr[index];
		switch(a){
			case 1:
				aturnLeft();
				break;
			case 2:
				aturnRight();
				break;
			case 3:
				moveForward();
				break;
			case 4:
				moveForward();
				break;
			case 5:
				moveForward();
				break;
			case 6:
				moveForward();
				break;
		}
	}
	int b = arr[length - 1];
	// Turn/Straight and start parking
}

void moveForward(){
	motor[motorL] = 75;
	motor[motorR] = 75;

	wait1Msec(500); // wait for the robot to leave the red line

	while(!(SensorValue[sensorF] > 55 && SensorValue[sensorF] < 65)){ // while it is not red
		motor[motorL] = 75;
		motor[motorR] = 75;
	}

	motor[motorL] = 0;
	motor[motorR] = 0;
}

void aturnLeft(){
	motor[motorL] = -75;
	motor[motorR] = 75;
	wait1Msec(2000);
}

void aturnRight(){
	motor[motorL] = 75;
	motor[motorR] = -75;
	wait1Msec(2000);
}

/*
bool collision(){
if(getUSDistance(sensorD) < 10)
return true;
return false;
}
*/
