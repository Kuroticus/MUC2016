#pragma config(Sensor, S1,     sensorL,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     sensorF,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     sensorR,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sensorD,        sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          motorL,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          motorR,        tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// writeDebugStream() is printf()
// 1 to turn left, 2 to turn right, 3 to go straight, 456 are saved for circular path
int arr[3] = {1, 2, 3};

task amove;
task aturnLeft;
task aturnRight;

task main(){
	int index;
	int length = sizeof(arr) / 2; //divide by 2 for int, divide by 20 for string
	for(index = 0; index < length; index++){
		int a = arr[index];
		switch(a){
			case 1:
				startTask(aturnLeft);
				break;
			case 2:
				startTask(aturnRight);
				break;
			case 3:
				startTask(amove);
				break;
			case 4:
				startTask(amove);
				break;
			case 5:
				startTask(amove);
				break;
			case 6:
				startTask(amove);
				break;
		}
	}
}

task amove(){
	motor[motorL] = 75;
	motor[motorR] = 75;
	wait1Msec(3000);

	motor[motorL] = 0;
	motor[motorR] = 0;
}

task aturnLeft(){
	motor[motorL] = -75;
	motor[motorR] = 75;
	wait1Msec(2000);
}

task aturnRight(){
	motor[motorL] = 75;
	motor[motorR] = -75;
	wait1Msec(2000);
}

/*
bool collision(){
if(getUSDistance(sensorD) < 10)
return true;
return false;
}
*/
